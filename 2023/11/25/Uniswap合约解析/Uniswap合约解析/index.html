<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Uniswap合约解析 | VVolfBite</title><meta name="author" content="VVolfBite"><meta name="copyright" content="VVolfBite"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Uniswap是知名的DEFI，这里解读其核心合约"><link rel="shortcut icon" href="/./img/favicon.png"><link rel="canonical" href="http://vvolfbite.github.io/2023/11/25/Uniswap%E5%90%88%E7%BA%A6%E8%A7%A3%E6%9E%90/Uniswap%E5%90%88%E7%BA%A6%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"IN70TNVHGI","apiKey":"96c696caac30cd17664660132cef736f","indexName":"IndexForVVolfBiteBlog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Uniswap合约解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-25 20:44:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/image/"><i class="fa-fw fa-solid fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/a6.png')"><nav id="nav"><span id="blog-info"><a href="/" title="VVolfBite"><span class="site-name">VVolfBite</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/image/"><i class="fa-fw fa-solid fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Uniswap合约解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-25T12:44:32.000Z" title="发表于 2023-11-25 20:44:32">2023-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-25T12:44:32.000Z" title="更新于 2023-11-25 20:44:32">2023-11-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E4%BD%9C/">工作</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E4%BD%9C/Uniswap/">Uniswap</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Uniswap合约解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Uniswap合约"><a href="#Uniswap合约" class="headerlink" title="Uniswap合约"></a>Uniswap合约</h1><p>这里主要参考了文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.ccvalue.cn/article/1031408.html">重新理解Uniswap V3：一次非常精彩的创新 - 碳链价值 (ccvalue.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/592696536">UniswapV3简析(一) - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1850737">UniSwap V3协议浅析(下)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><img src="https://pic1.zhimg.com/80/v2-4f8faa69a994cedefce7283d3b524c68_720w.webp" alt="img"></p>
<p>Uniswap核心分为核心合约(core contracts )与外围合约(periphery contracts)两部分组成.</p>
<h2 id="核心合约"><a href="#核心合约" class="headerlink" title="核心合约"></a>核心合约</h2><p>核心合约主要包括 UniswapV3Pool, UniswapV3Factory,UniswapV3PoolDeployer等，其他合约大多为实现某个类型的某些功能。</p>
<h3 id="Factory合约"><a href="#Factory合约" class="headerlink" title="Factory合约"></a>Factory合约</h3><p>​    UniswapV3Factory的主要功能是提供创建pool的接口并且跟踪所有的pool。</p>
<p>合约最初声明当前工程合约的owner、费用的tickSpacing(刻度间距，如果为0则表示未启用，一经添加无法删除)、根据token与fee检索交易池的映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3Factory</span><br><span class="line">address public override owner;</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3Factory</span><br><span class="line">mapping(uint24 =&gt; int24) public override feeAmountTickSpacing;</span><br><span class="line">/// @inheritdoc IUniswapV3Factory</span><br><span class="line">mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;</span><br></pre></td></tr></table></figure>

<p>之后通过构造函数初始化的合约的owner以及三个TickSpace(没理解错的话一个tick和上一个tick价格差距0.01% 所以上下10个tick相当于0.1%左右的范围)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    emit OwnerChanged(address(0), msg.sender);</span><br><span class="line"></span><br><span class="line">    feeAmountTickSpacing[500] = 10;</span><br><span class="line">    emit FeeAmountEnabled(500, 10);</span><br><span class="line">    feeAmountTickSpacing[3000] = 60;</span><br><span class="line">    emit FeeAmountEnabled(3000, 60);</span><br><span class="line">    feeAmountTickSpacing[10000] = 200;</span><br><span class="line">    emit FeeAmountEnabled(10000, 200);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义的三个TickSpace与费率的关系如下所示：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-8423247/ac91653052761821e8ea58cc2aaab94e.png" alt="img"></p>
<p>之后通过createPool来创建交易池，此时需要提供以下三个参数：</p>
<ul>
<li>fee:期望的费率</li>
<li>tokenA：交易池中的两个Token之一</li>
<li>tokenB：交易池中的两个Token之一</li>
</ul>
<p>在createPool函数中首先会检查tokenA与tokenB是否是同一Token，之后将TokenA与TokenB根据地址进行升序排列为token0和token1(token0成为基础币而token1成为价值衡量币)，之后检查token0地址是否为空地址，之后根据费率检索TickSpace并检查TickSpace是否为0(构造函数会进行初始化一次)，之后检查当前新建的池子是否已经存在，之后通过deploy创建池子，然后新增池子记录，在新增记录时可以看到也提供了反向映射，这样做的好处是在减少后期检索时比较地址的成本，最后通过emit触发池子创建事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    /// @inheritdoc IUniswapV3Factory</span><br><span class="line">    function createPool(</span><br><span class="line">        address tokenA,</span><br><span class="line">        address tokenB,</span><br><span class="line">        uint24 fee</span><br><span class="line">) external override noDelegateCall returns (address pool) &#123;</span><br><span class="line">        require(tokenA != tokenB);</span><br><span class="line">        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">        require(token0 != address(0));</span><br><span class="line">        int24 tickSpacing = feeAmountTickSpacing[fee];</span><br><span class="line">        require(tickSpacing != 0);</span><br><span class="line">        require(getPool[token0][token1][fee] == address(0));</span><br><span class="line">        pool = deploy(address(this), token0, token1, fee, tickSpacing);</span><br><span class="line">        getPool[token0][token1][fee] = pool;</span><br><span class="line">        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses</span><br><span class="line">        getPool[token1][token0][fee] = pool;</span><br><span class="line">        emit PoolCreated(token0, token1, fee, tickSpacing, pool);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之后的setOwner函数用于更新工厂合约的owner，该函数只能由合约的owner调用，在更新时通过emit来触发owner变更事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3Factory</span><br><span class="line">function setOwner(address _owner) external override &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    emit OwnerChanged(owner, _owner);</span><br><span class="line">    owner = _owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enableFeeAmount函数用于新增tickSpacing(刻度间距)的费率，该函数只能由合约的owner调用，在函数中首先对参数进行合法性检查，在这里要求费率不得超过1000000(即:100%)，tickSpacing不得超过16384以防止tickSpacing过大，之后检查该费率是否已经存在，之后对给定tickSpacing设置费率，之后通过emit触发事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3Factory</span><br><span class="line">function enableFeeAmount(uint24 fee, int24 tickSpacing) public override &#123;</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    require(fee &lt; 1000000);</span><br><span class="line">    // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that</span><br><span class="line">    // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick</span><br><span class="line">    // 16384 ticks represents a &gt;5x price change with ticks of 1 bips</span><br><span class="line">    require(tickSpacing &gt; 0 &amp;&amp; tickSpacing &lt; 16384);</span><br><span class="line">    require(feeAmountTickSpacing[fee] == 0);</span><br><span class="line"></span><br><span class="line">    feeAmountTickSpacing[fee] = tickSpacing;</span><br><span class="line">    emit FeeAmountEnabled(fee, tickSpacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PoolDeployer合约"><a href="#PoolDeployer合约" class="headerlink" title="PoolDeployer合约"></a>PoolDeployer合约</h3><p>​    UniswapV3PoolDeployer合约主要提供deploy函数来创建UniswapV3Pool智能合约并设置两个token信息，交易费用信息和tick的步长信息.</p>
<p>其只有一个deploy函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function deploy(</span><br><span class="line">    address factory,</span><br><span class="line">    address token0,</span><br><span class="line">    address token1,</span><br><span class="line">    uint24 fee,</span><br><span class="line">    int24 tickSpacing</span><br><span class="line">) internal returns (address pool) &#123;</span><br><span class="line">    parameters = Parameters(&#123;factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing&#125;);</span><br><span class="line">    pool = address(new UniswapV3Pool&#123;salt: keccak256(abi.encode(token0, token1, fee))&#125;());</span><br><span class="line">    delete parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deploy函数首先将参数再次作为参数初始化为一个Parameters的结构体变量，之后通过keccak256(abi.encode(token0, token1, fee)将token0、token1、fee作为参数得到一个哈希值，之后将其作为salt来创建合约，故而solidity会使用EVM的CREATE2指令来创建合约，这里使用CREATE2指令的一个好处就是，只要合约的bytecode及salt不变，那么创建出来的地址也将不变，也就是说每个交易池都有一个唯一的地址，之后清空结构体变量.</p>
<h3 id="Pool合约"><a href="#Pool合约" class="headerlink" title="Pool合约"></a>Pool合约</h3><p><img src="https://pic2.zhimg.com/80/v2-d336608dc0fdcad547358f2d26e41535_720w.webp" alt="img"></p>
<p>​    Pool合约主要实现代币交易、流动性管理、交易手续费收取、Oracle管理等。Uniswap本质上是由N多个独立的流动池构成, 每个流动池由(token0,token1,fee)三个参数唯一进行标识, 通过这三个参数可以唯一检索出对应的Pool地址。</p>
<ul>
<li>token0：作为基准货币</li>
<li>token1：作为价值衡量货币</li>
<li>fee：手续费用</li>
</ul>
<p>​    每一个流动池Pool实际上是一个流动性聚合器, 可以同时添加多个流动性仓位, 每个流动性仓位由(owner,tickLower,tickUpper)三个参数唯一标识，通过上面三个参数唯一检索出对应的流动性仓位Position：这里的仓位拥有者都是NonfungiblePositionManager合约, 而不是实际的用户地址。</p>
<ul>
<li>owner: 流动性仓位的拥有者地址(实际上就是NonfungiblePositionManager合约)</li>
<li>tickLower: 流动性仓位做市区间最低价的tick索引</li>
<li>tickUpper: 流动性仓位做市区间最高价的tick索引</li>
</ul>
<p>首先，声明了合约中使用到的全局变量，之后定义了结构体Slot0(一个用于采样池子最新状况的结构，当前最新price、当前tick、协议费用、池子状态(开启或关闭))、结构体ProtocolFees等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">using LowGasSafeMath for uint256;</span><br><span class="line">using LowGasSafeMath for int256;</span><br><span class="line">using SafeCast for uint256;</span><br><span class="line">using SafeCast for int256;</span><br><span class="line">using Tick for mapping(int24 =&gt; Tick.Info);</span><br><span class="line">using TickBitmap for mapping(int16 =&gt; uint256);</span><br><span class="line">using Position for mapping(bytes32 =&gt; Position.Info);</span><br><span class="line">using Position for Position.Info;</span><br><span class="line">using Oracle for Oracle.Observation[65535];</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3PoolImmutables</span><br><span class="line">address public immutable override factory;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolImmutables</span><br><span class="line">address public immutable override token0;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolImmutables</span><br><span class="line">address public immutable override token1;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolImmutables</span><br><span class="line">uint24 public immutable override fee;</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3PoolImmutables</span><br><span class="line">int24 public immutable override tickSpacing;      // 刻度间隔</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3PoolImmutables</span><br><span class="line">uint128 public immutable override maxLiquidityPerTick; // 可使用范围内任何刻度的头寸流动性的最大金额</span><br><span class="line"></span><br><span class="line">struct Slot0 &#123;</span><br><span class="line">    // the current price</span><br><span class="line">    uint160 sqrtPriceX96;</span><br><span class="line">    // the current tick</span><br><span class="line">    int24 tick;</span><br><span class="line">    // the most-recently updated index of the observations array</span><br><span class="line">    uint16 observationIndex;</span><br><span class="line">    // the current maximum number of observations that are being stored</span><br><span class="line">    uint16 observationCardinality;</span><br><span class="line">    // the next maximum number of observations to store, triggered in observations.write</span><br><span class="line">    uint16 observationCardinalityNext;</span><br><span class="line">    // the current protocol fee as a percentage of the swap fee taken on withdrawal</span><br><span class="line">    // represented as an integer denominator (1/x)%</span><br><span class="line">    uint8 feeProtocol;</span><br><span class="line">    // whether the pool is locked</span><br><span class="line">    bool unlocked;</span><br><span class="line">&#125;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">Slot0 public override slot0;</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">uint256 public override feeGrowthGlobal0X128;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">uint256 public override feeGrowthGlobal1X128;</span><br><span class="line"></span><br><span class="line">// accumulated protocol fees in token0/token1 units</span><br><span class="line">struct ProtocolFees &#123;</span><br><span class="line">    uint128 token0;</span><br><span class="line">    uint128 token1;</span><br><span class="line">&#125;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">ProtocolFees public override protocolFees;</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">uint128 public override liquidity;</span><br><span class="line"></span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">mapping(int24 =&gt; Tick.Info) public override ticks;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">mapping(int16 =&gt; uint256) public override tickBitmap;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">mapping(bytes32 =&gt; Position.Info) public override positions;</span><br><span class="line">/// @inheritdoc IUniswapV3PoolState</span><br><span class="line">Oracle.Observation[65535] public override observations;</span><br></pre></td></tr></table></figure>

<p>修饰器lock用于提供锁机制来规避重入攻击，此方法还可以防止在初始化池之前调用函数，重入保护在整个合约中是必需的，因为我们经常使用余额检查来确定交互(如铸币、掉期和闪存)的支付状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance</span><br><span class="line">/// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because</span><br><span class="line">/// we use balance checks to determine the payment status of interactions such as mint, swap and flash.</span><br><span class="line">modifier lock() &#123;</span><br><span class="line">    require(slot0.unlocked, &#x27;LOK&#x27;);</span><br><span class="line">    slot0.unlocked = false;</span><br><span class="line">    _;</span><br><span class="line">    slot0.unlocked = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰器onlyFactoryOwner用于检测函数的调用者是否为工程合约的owner地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()</span><br><span class="line">modifier onlyFactoryOwner() &#123;</span><br><span class="line">    require(msg.sender == IUniswapV3Factory(factory).owner());</span><br><span class="line">    _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数用于初始化一个池子，其实完整的流程应该为：</p>
<p>UniswapV3Factory.sol(createPool)—&gt;UniswapV3PoolDeployer.sol(deploy)—&gt;UniswapV3Pool.sol(constructor)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor() &#123;</span><br><span class="line">    int24 _tickSpacing;</span><br><span class="line">    (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();</span><br><span class="line">    tickSpacing = _tickSpacing;</span><br><span class="line"></span><br><span class="line">    maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>checkTicks函数用于检测流动性的价格上限与流动性的价格下限的合法性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// @dev Common checks for valid tick inputs.</span><br><span class="line">function checkTicks(int24 tickLower, int24 tickUpper) private pure &#123;</span><br><span class="line">    require(tickLower &lt; tickUpper, &#x27;TLU&#x27;);</span><br><span class="line">    require(tickLower &gt;= TickMath.MIN_TICK, &#x27;TLM&#x27;);</span><br><span class="line">    require(tickUpper &lt;= TickMath.MAX_TICK, &#x27;TUM&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数_blockTimestamp用于返回截断后(32位)的区块时间戳信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.</span><br><span class="line">function _blockTimestamp() internal view virtual returns (uint32) &#123;</span><br><span class="line">    return uint32(block.timestamp); // truncation is desired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>balance0与balance1函数用于检索池子中token0与token1的资产数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/// @dev Get the pool&#x27;s balance of token0</span><br><span class="line">/// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize</span><br><span class="line">/// check</span><br><span class="line">function balance0() private view returns (uint256) &#123;</span><br><span class="line">    (bool success, bytes memory data) =</span><br><span class="line">        token0.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));</span><br><span class="line">    require(success &amp;&amp; data.length &gt;= 32);</span><br><span class="line">    return abi.decode(data, (uint256));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @dev Get the pool&#x27;s balance of token1</span><br><span class="line">/// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize</span><br><span class="line">/// check</span><br><span class="line">function balance1() private view returns (uint256) &#123;</span><br><span class="line">    (bool success, bytes memory data) =</span><br><span class="line">        token1.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));</span><br><span class="line">    require(success &amp;&amp; data.length &gt;= 32);</span><br><span class="line">    return abi.decode(data, (uint256));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h4><p>initialize函数用于对交易池进行初始化，主要涉及池子价格、tick、协议费用等，这里的sqrtPriceX96为sqrt(amountToken1/amountToken0)Q64.96精度的定点数值，在这里首先检查池子价格是否未初始化，之后调用getTickAtSqrtRatio函数以sqrtPriceX96为参数来计算最大的tick，之后调用observations.initialize获取cardinality(基数)与cardinalityNext(下一个基数)的数值，之后对slot0进行初始化操作，完成交易池的创建，当然此时交易池里面还没有流动性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3PoolActions</span><br><span class="line">/// @dev not locked because it initializes unlocked</span><br><span class="line">function initialize(uint160 sqrtPriceX96) external override &#123;</span><br><span class="line">    require(slot0.sqrtPriceX96 == 0, &#x27;AI&#x27;);</span><br><span class="line"></span><br><span class="line">    int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span><br><span class="line"></span><br><span class="line">    (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());</span><br><span class="line"></span><br><span class="line">    slot0 = Slot0(&#123;</span><br><span class="line">        sqrtPriceX96: sqrtPriceX96,</span><br><span class="line">        tick: tick,</span><br><span class="line">        observationIndex: 0,</span><br><span class="line">        observationCardinality: cardinality,</span><br><span class="line">        observationCardinalityNext: cardinalityNext,</span><br><span class="line">        feeProtocol: 0,</span><br><span class="line">        unlocked: true</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    emit Initialize(sqrtPriceX96, tick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mint"><a href="#Mint" class="headerlink" title="Mint"></a>Mint</h4><p><img src="https://pic1.zhimg.com/80/v2-afca012d34c2c5eb20a91c0fb75f7d20_720w.webp" alt="img"></p>
<p>mint函数用于添加流动性（流动性实际是一直ERC20标准的代币，我猜测是为了随时跟踪各个池子的情况），相关参数如下：</p>
<ul>
<li>recipient - 流动性仓位的拥有者地址</li>
<li>tickLower - 流动性仓位做市价格区间(也叫做流动性头寸）最低点位</li>
<li>tickUpper - 流动性仓位做市价格区间最高点位</li>
<li>amount - 要添加的流动性大小, 也就是L的值</li>
<li>data - 回调函数参数</li>
</ul>
<p>在这里首先检查增加的流动性的数量是否大于0，之后调用ModifyPositionParams初始化一个Position结构体的示例，之后再次调用_modifyPosition来调整仓位Position，该函数调用完之后会返回应投入的token0和token1的数量，之后获取当前池子之前的token0和token1的数量，之后将需要投入的token0和token1的数量传给NonfungiblePositionManager合约的uniswapV3MintCallback回调函数, 在这个函数里面完成真正的转账充值工作, 然后会检查是否成功收到转账, 如果出现问题系统会进行回滚，如果满足则通过emit触发事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3PoolActions</span><br><span class="line">/// @dev noDelegateCall is applied indirectly via _modifyPosition</span><br><span class="line">function mint(</span><br><span class="line">    address recipient,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    require(amount &gt; 0);</span><br><span class="line">    (, int256 amount0Int, int256 amount1Int) =</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: recipient,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 = uint256(amount0Int);</span><br><span class="line">    amount1 = uint256(amount1Int);</span><br><span class="line"></span><br><span class="line">    uint256 balance0Before;</span><br><span class="line">    uint256 balance1Before;</span><br><span class="line">    if (amount0 &gt; 0) balance0Before = balance0();</span><br><span class="line">    if (amount1 &gt; 0) balance1Before = balance1();</span><br><span class="line">    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);</span><br><span class="line">    if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;= balance0(), &#x27;M0&#x27;);</span><br><span class="line">    if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;= balance1(), &#x27;M1&#x27;);</span><br><span class="line"></span><br><span class="line">    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    _modifyPosition会依据做市价格区间及其流动L的大小计算需要充值的token0,token1的数量, 假设当前流动池价格为Pc, 用户添加流动性仓位的价格区间的 [Pa, Pb] (Pa &lt; Pb), 实际会分为三种情况：</p>
<ol>
<li>做市价格区间大于当前实际价格, 只能添加x token, 如下图:</li>
</ol>
<p><img src="https://pic2.zhimg.com/80/v2-b207b879cc3f30fb692db160078f8349_720w.webp" alt="img"></p>
<p>流动性L的计算公式为:</p>
<p><img src="https://pic1.zhimg.com/80/v2-37c1d5345a579fd4daa7c1b12d8f888c_720w.webp" alt="img"></p>
<ol start="2">
<li>做市价格区间小于当前实际价格, 只能添加y token, 如下图:</li>
</ol>
<p><img src="https://pic2.zhimg.com/80/v2-f9e7a40ce6b0d5f4a6b0105218349c21_720w.webp" alt="img"></p>
<p>流动性L的计算公式为:</p>
<p><img src="https://pic4.zhimg.com/80/v2-a13d4d9c1bbe5eddd382c9ec52e26a37_720w.webp" alt="img"></p>
<ol start="3">
<li>做市价格区间包含当前实际价格, 按一定比例分别添加x token和y token, 如下图:</li>
</ol>
<p><img src="https://pic2.zhimg.com/80/v2-bad293f2a809ff76d9c371ca9eeec485_720w.webp" alt="img"></p>
<p>流动性L的计算公式为:</p>
<p><img src="https://pic1.zhimg.com/80/v2-2e7a9da2eb7ab355cad505f8adf6f19c_720w.webp" alt="img"></p>
<p>下面对上述涉及到的相关函数方法进行简易拆分：</p>
<p>ModifyPositionParams——用于存储Position(流动性仓位)相关的数据信息，包括流动性仓位所有者地址、流动性仓位的上下限、流动性的改动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ModifyPositionParams &#123;</span><br><span class="line">    // the address that owns the position</span><br><span class="line">    address owner;</span><br><span class="line">    // the lower and upper tick of the position</span><br><span class="line">    int24 tickLower;</span><br><span class="line">    int24 tickUpper;</span><br><span class="line">    // any change in liquidity</span><br><span class="line">    int128 liquidityDelta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_modifyPosition——用于更新当前Position，在这里首先通过checkTicks来检查流动性上下限是否满足条件，之后将其读入内存(Slot0 memory _slot0 = slot0;)，后续通过SLOAD直接访问而不用重新去加载LOAD，从而节省gas，紧接着又调用了_updatePosition来更新position，紧接着检查当前流动性的变更是否为0，如果不为0则检查当前的tick是否小于ticklower，如果是则所有的token1将转变为token0，之后计算token0的变更；如果当前tick在两者之间，则通过observations.write增加Oracle条目，之后计算amout0和amount1的增量，最后当前tick范围内的流动性总量；如果tick超过了tickupper则此时所有的token0将转变为token1，之后计算amount1的变更，需要注意的是这里的amount0与amount1为int256类型，也就是说这里的amount0与amount1这两个返回值可正可负，如果为正则表示流动性提供者需要给池子给予的数量，为负数则表示池子需要给流动性提供者给予的数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">    /// @dev Effect some changes to a position</span><br><span class="line">    /// @param params the position details and the change to the position&#x27;s liquidity to effect</span><br><span class="line">    /// @return position a storage pointer referencing the position with the given owner and tick range</span><br><span class="line">    /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient</span><br><span class="line">    /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient</span><br><span class="line">    function _modifyPosition(ModifyPositionParams memory params)</span><br><span class="line">        private</span><br><span class="line">        noDelegateCall</span><br><span class="line">        returns (</span><br><span class="line">            Position.Info storage position,</span><br><span class="line">            int256 amount0,</span><br><span class="line">            int256 amount1</span><br><span class="line">)</span><br><span class="line">    &#123;</span><br><span class="line">        checkTicks(params.tickLower, params.tickUpper);</span><br><span class="line"></span><br><span class="line">        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization</span><br><span class="line"></span><br><span class="line">        position = _updatePosition(</span><br><span class="line">            params.owner,</span><br><span class="line">            params.tickLower,</span><br><span class="line">            params.tickUpper,</span><br><span class="line">            params.liquidityDelta,</span><br><span class="line">            _slot0.tick</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        if (params.liquidityDelta != 0) &#123;</span><br><span class="line">            if (_slot0.tick &lt; params.tickLower) &#123;</span><br><span class="line">                // current tick is below the passed range; liquidity can only become in range by crossing from left to</span><br><span class="line">                // right, when we&#x27;ll need _more_ token0 (it&#x27;s becoming more valuable) so user must provide it</span><br><span class="line">                amount0 = SqrtPriceMath.getAmount0Delta(</span><br><span class="line">                    TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                    params.liquidityDelta</span><br><span class="line">                );</span><br><span class="line">            &#125; else if (_slot0.tick &lt; params.tickUpper) &#123;</span><br><span class="line">                // current tick is inside the passed range</span><br><span class="line">                uint128 liquidityBefore = liquidity; // SLOAD for gas optimization</span><br><span class="line"></span><br><span class="line">                // write an oracle entry</span><br><span class="line">                (slot0.observationIndex, slot0.observationCardinality) = observations.write(</span><br><span class="line">                    _slot0.observationIndex,</span><br><span class="line">                    _blockTimestamp(),</span><br><span class="line">                    _slot0.tick,</span><br><span class="line">                    liquidityBefore,</span><br><span class="line">                    _slot0.observationCardinality,</span><br><span class="line">                    _slot0.observationCardinalityNext</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                amount0 = SqrtPriceMath.getAmount0Delta(</span><br><span class="line">                    _slot0.sqrtPriceX96,</span><br><span class="line">                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                    params.liquidityDelta</span><br><span class="line">                );</span><br><span class="line">                amount1 = SqrtPriceMath.getAmount1Delta(</span><br><span class="line">                    TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                    _slot0.sqrtPriceX96,</span><br><span class="line">                    params.liquidityDelta</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // current tick is above the passed range; liquidity can only become in range by crossing from right to</span><br><span class="line">                // left, when we&#x27;ll need _more_ token1 (it&#x27;s becoming more valuable) so user must provide it</span><br><span class="line">                amount1 = SqrtPriceMath.getAmount1Delta(</span><br><span class="line">                    TickMath.getSqrtRatioAtTick(params.tickLower),</span><br><span class="line">                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span><br><span class="line">                    params.liquidityDelta</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>_updatePosition函数，该函数代码如下，在这里首先通过get函数来获取用户的position信息，之后检查流动性变更是否为0，如果不为零则获取当前时间戳信息并通过observations.observeSingle来获取请求时间点的Oracle数据，之后更新position对应的ticklower/tickupper的数据，之后检查flippedLower是否是第一次被引用，或者移除了所有引用(移除流动性操作时)，如果是则更新tick位图，之后更新position数据，并清除之前的记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/// @dev Gets and updates a position with the given liquidity delta</span><br><span class="line">/// @param owner the owner of the position</span><br><span class="line">/// @param tickLower the lower tick of the position&#x27;s tick range</span><br><span class="line">/// @param tickUpper the upper tick of the position&#x27;s tick range</span><br><span class="line">/// @param tick the current tick, passed to avoid sloads</span><br><span class="line">function _updatePosition(</span><br><span class="line">    address owner,</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    int128 liquidityDelta,</span><br><span class="line">    int24 tick</span><br><span class="line">) private returns (Position.Info storage position) &#123;</span><br><span class="line">    position = positions.get(owner, tickLower, tickUpper);</span><br><span class="line"></span><br><span class="line">    uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization</span><br><span class="line">    uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization</span><br><span class="line"></span><br><span class="line">    // if we need to update the ticks, do it</span><br><span class="line">    bool flippedLower;</span><br><span class="line">    bool flippedUpper;</span><br><span class="line">    if (liquidityDelta != 0) &#123;</span><br><span class="line">        uint32 time = _blockTimestamp();</span><br><span class="line">        (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) =</span><br><span class="line">            observations.observeSingle(</span><br><span class="line">                time,</span><br><span class="line">                0,</span><br><span class="line">                slot0.tick,</span><br><span class="line">                slot0.observationIndex,</span><br><span class="line">                liquidity,</span><br><span class="line">                slot0.observationCardinality</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        flippedLower = ticks.update(</span><br><span class="line">            tickLower,</span><br><span class="line">            tick,</span><br><span class="line">            liquidityDelta,</span><br><span class="line">            _feeGrowthGlobal0X128,</span><br><span class="line">            _feeGrowthGlobal1X128,</span><br><span class="line">            secondsPerLiquidityCumulativeX128,</span><br><span class="line">            tickCumulative,</span><br><span class="line">            time,</span><br><span class="line">            false,</span><br><span class="line">            maxLiquidityPerTick</span><br><span class="line">        );</span><br><span class="line">        flippedUpper = ticks.update(</span><br><span class="line">            tickUpper,</span><br><span class="line">            tick,</span><br><span class="line">            liquidityDelta,</span><br><span class="line">            _feeGrowthGlobal0X128,</span><br><span class="line">            _feeGrowthGlobal1X128,</span><br><span class="line">            secondsPerLiquidityCumulativeX128,</span><br><span class="line">            tickCumulative,</span><br><span class="line">            time,</span><br><span class="line">            true,</span><br><span class="line">            maxLiquidityPerTick</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        if (flippedLower) &#123;</span><br><span class="line">            tickBitmap.flipTick(tickLower, tickSpacing);</span><br><span class="line">        &#125;</span><br><span class="line">        if (flippedUpper) &#123;</span><br><span class="line">            tickBitmap.flipTick(tickUpper, tickSpacing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =</span><br><span class="line">        ticks.getFeeGrowthInside(tickLower, tickUpper, tick, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128);</span><br><span class="line"></span><br><span class="line">    position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);</span><br><span class="line"></span><br><span class="line">    // clear any tick data that is no longer needed</span><br><span class="line">    if (liquidityDelta &lt; 0) &#123;</span><br><span class="line">        if (flippedLower) &#123;</span><br><span class="line">            ticks.clear(tickLower);</span><br><span class="line">        &#125;</span><br><span class="line">        if (flippedUpper) &#123;</span><br><span class="line">            ticks.clear(tickUpper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uniswapV3MintCallback——即回调函数，该函数会将指定数量的token0与token1发送到合约中去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function uniswapV3MintCallback(</span><br><span class="line">    uint256 amount0Owed,</span><br><span class="line">    uint256 amount1Owed,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override &#123;</span><br><span class="line">    address sender = abi.decode(data, (address));</span><br><span class="line"></span><br><span class="line">    emit MintCallback(amount0Owed, amount1Owed);</span><br><span class="line">    if (amount0Owed &gt; 0)</span><br><span class="line">        IERC20Minimal(IUniswapV3Pool(msg.sender).token0()).transferFrom(sender, msg.sender, amount0Owed);</span><br><span class="line">    if (amount1Owed &gt; 0)</span><br><span class="line">        IERC20Minimal(IUniswapV3Pool(msg.sender).token1()).transferFrom(sender, msg.sender, amount1Owed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Burn"><a href="#Burn" class="headerlink" title="Burn"></a>Burn</h4><p>burn函数用于移除流动性，和之前的mint函数正好相逆，相关参数如下：</p>
<ul>
<li>tickLower - 做市价格区间最低点位, 用于检索对应流动性仓位</li>
<li>tickUpper - 做市价格区间最高点位, 用于检索对应流动性仓位</li>
<li>amount - 要减少的流动性数量, 也就是L值</li>
</ul>
<p>函数首先初始化一个ModifyPositionParams结构体类型的示例，之后调用_modifyPosition来修改position，因为减少了流动性, 所以必然会空闲出相应数量的token, 程序会把空闲出来的token数量保存到对应仓位的position.tokensOwed0,position.tokensOwed1成员变量中,需要强调的是, 这里仅仅只是记录空闲出来的token数量, 而并不会把这些token返还给客户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3PoolActions</span><br><span class="line">/// @dev noDelegateCall is applied indirectly via _modifyPosition</span><br><span class="line">function burn(</span><br><span class="line">    int24 tickLower,</span><br><span class="line">    int24 tickUpper,</span><br><span class="line">    uint128 amount</span><br><span class="line">) external override lock returns (uint256 amount0, uint256 amount1) &#123;</span><br><span class="line">    (Position.Info storage position, int256 amount0Int, int256 amount1Int) =</span><br><span class="line">        _modifyPosition(</span><br><span class="line">            ModifyPositionParams(&#123;</span><br><span class="line">                owner: msg.sender,</span><br><span class="line">                tickLower: tickLower,</span><br><span class="line">                tickUpper: tickUpper,</span><br><span class="line">                liquidityDelta: -int256(amount).toInt128()</span><br><span class="line">            &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    amount0 = uint256(-amount0Int);</span><br><span class="line">    amount1 = uint256(-amount1Int);</span><br><span class="line"></span><br><span class="line">    if (amount0 &gt; 0 || amount1 &gt; 0) &#123;</span><br><span class="line">        (position.tokensOwed0, position.tokensOwed1) = (</span><br><span class="line">            position.tokensOwed0 + uint128(amount0),</span><br><span class="line">            position.tokensOwed1 + uint128(amount1)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Collect"><a href="#Collect" class="headerlink" title="Collect"></a>Collect</h4><p>collect函数用于提取闲置token及其手续费，相关参数如下所示：</p>
<ul>
<li>recipient - 接收返还的用户地址</li>
<li>tickLower - 做市价格区间最低点位, 用于检索对应流动性仓位</li>
<li>tickUpper - 做市价格区间最高点位, 用于检索对应流动性仓位</li>
<li>amount0Requested - 想要提取的token0数量</li>
<li>amount1Requested - 想要提取的token1数量</li>
</ul>
<p>当用户进行减少流动性的操作后, 空闲出来的token数量会被保存到对应仓位的position.tokensOwed0,position.tokensOwed1成员变量中, 另外就是用户充当LP赚取的手续费也会保存在这俩成员变量中, 本函数会真正将相应数量的token返还给用户。首先通过positions.get获取当前用户position信息，之后根据参数调整需要收取的手续费，并将手续费发送给流动性提供者指定的用于接受手续费的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    /// @inheritdoc IUniswapV3PoolActions</span><br><span class="line">    function collect(</span><br><span class="line">        address recipient,</span><br><span class="line">        int24 tickLower,</span><br><span class="line">        int24 tickUpper,</span><br><span class="line">        uint128 amount0Requested,</span><br><span class="line">        uint128 amount1Requested</span><br><span class="line">) external override lock returns (uint128 amount0, uint128 amount1) &#123;</span><br><span class="line">        // we don&#x27;t need to checkTicks here, because invalid positions will never have non-zero tokensOwed&#123;0,1&#125;</span><br><span class="line">        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);</span><br><span class="line"></span><br><span class="line">        amount0 = amount0Requested &gt; position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;</span><br><span class="line">        amount1 = amount1Requested &gt; position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;</span><br><span class="line"></span><br><span class="line">        if (amount0 &gt; 0) &#123;</span><br><span class="line">            position.tokensOwed0 -= amount0;</span><br><span class="line">            TransferHelper.safeTransfer(token0, recipient, amount0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (amount1 &gt; 0) &#123;</span><br><span class="line">            position.tokensOwed1 -= amount1;</span><br><span class="line">            TransferHelper.safeTransfer(token1, recipient, amount1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h4><p>swap函数主要用于处理交易，提供token交易兑换功能, 算是较为复杂的部分, 因为交易过程中可能会跨越多个流动性仓位, 算法有一定的复杂性，相关参数说明：</p>
<ul>
<li>recipient - 接收兑换输出的地址</li>
<li>zeroForOne - 兑换方向, 当true时兑换方向为:token0-&gt;token1, 当false时兑换方向为:token1到token0</li>
<li>amountSpecified - 兑换数量, 当数值为正数代表是输入token的数量, 当数值为负数代表想达到的输出token数量</li>
<li>sqrtPriceLimitX96 - 价格限制, 根据方向最终价格不能大于或者小于该值</li>
<li>data - 回调函数参数</li>
</ul>
<p>基本逻辑就是:</p>
<p>1.已知输入token的数量, 计算出可以输出多少数量的token, 及其兑换结束后价格移动到什么点位</p>
<p>2.已知输出token的数量, 计算出需要多少数量的输入token, 及其兑换结束后价格移动到什么点位</p>
<p>分为四种情况处理:</p>
<ol>
<li><p>(zeroForOne:true, amountSpecified:正数) ==&gt;&gt; 我用amountSpecified数量的token0, 最多可以兑换多少数量的token1?</p>
</li>
<li><p>(zeroForOne:true, amountSpecified:负数) ==&gt;&gt; 我需要兑换abs(amountSpecified)数量的token1, 最少需要准备多少数量的token0?</p>
</li>
<li><p>(zeroForOne:false, amountSpecified:正数) ==&gt;&gt; 我用amountSpecified数量的token1, 最多可以兑换多少数量的token0?</p>
</li>
<li><p>(zeroForOne:false, amountSpecified:负数) ==&gt;&gt; 我需要兑换abs(amountSpecified)数量的token0, 最少需要准备多少数量的token1?</p>
</li>
</ol>
<p>真正在token交易过程中, 可能会涉及路径选择问题, 比如ETH-&gt;DAI, 可以直接在ETH/DAI流动池兑换, 也可以利用ETH-&gt;USDC-&gt;DAI这个路径, 通过ETH/USDC, USDC/DAI两个流动池接力完成兑换</p>
<p>至于采取哪个路径, 由链下前端决定, 链下前端会根据情况计算出最优路径, 关于程序中路径的编码如下图所示:</p>
<p><img src="https://pic3.zhimg.com/80/v2-2312c9a0d89d39f02a448a225dc6e562_720w.webp" alt="img"></p>
<p>当最终计算好要兑换的输入输出token数量以后, swap函数会首先将用户需求的token发送给用户, 然后会回调位于SwapRouter合约中的回调函数uniswapV3SwapCallback, 在uniswapV3SwapCallback函数中最终会用ERC20合约的transferFrom方法将用户的token转帐到流动池合约中, 至此完成兑换过程.</p>
<p>在这里首先检查交易数量是否为0，之后将交易前的数据保存在内存中，之后检查是否有正在进行的token交易操作，如果没有则根据交易方向检查价格是否满足在条件，之后更新slot0.unlocked的状态，之后缓存交易的数据，之后检查交换的数量是否大于0，并将其赋值于exactInput，之后存储交易状态信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    /// @inheritdoc IUniswapV3PoolActions</span><br><span class="line">    function swap(</span><br><span class="line">        address recipient,</span><br><span class="line">        bool zeroForOne,</span><br><span class="line">        int256 amountSpecified,</span><br><span class="line">        uint160 sqrtPriceLimitX96,</span><br><span class="line">        bytes calldata data</span><br><span class="line">) external override noDelegateCall returns (int256 amount0, int256 amount1) &#123;</span><br><span class="line">        require(amountSpecified != 0, &#x27;AS&#x27;);</span><br><span class="line"></span><br><span class="line">        Slot0 memory slot0Start = slot0;</span><br><span class="line"></span><br><span class="line">        require(slot0Start.unlocked, &#x27;LOK&#x27;);</span><br><span class="line">        require(</span><br><span class="line">            zeroForOne</span><br><span class="line">                ? sqrtPriceLimitX96 &lt; slot0Start.sqrtPriceX96 &amp;&amp; sqrtPriceLimitX96 &gt; TickMath.MIN_SQRT_RATIO</span><br><span class="line">                : sqrtPriceLimitX96 &gt; slot0Start.sqrtPriceX96 &amp;&amp; sqrtPriceLimitX96 &lt; TickMath.MAX_SQRT_RATIO,</span><br><span class="line">            &#x27;SPL&#x27;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        slot0.unlocked = false;</span><br><span class="line"></span><br><span class="line">        SwapCache memory cache =</span><br><span class="line">            SwapCache(&#123;</span><br><span class="line">                liquidityStart: liquidity,</span><br><span class="line">                blockTimestamp: _blockTimestamp(),</span><br><span class="line">                feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol &gt;&gt; 4),</span><br><span class="line">                secondsPerLiquidityCumulativeX128: 0,</span><br><span class="line">                tickCumulative: 0,</span><br><span class="line">                computedLatestObservation: false</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        bool exactInput = amountSpecified &gt; 0;</span><br><span class="line"></span><br><span class="line">        SwapState memory state =</span><br><span class="line">            SwapState(&#123;</span><br><span class="line">                amountSpecifiedRemaining: amountSpecified,</span><br><span class="line">                amountCalculated: 0,</span><br><span class="line">                sqrtPriceX96: slot0Start.sqrtPriceX96,</span><br><span class="line">                tick: slot0Start.tick,</span><br><span class="line">                feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,</span><br><span class="line">                protocolFee: 0,</span><br><span class="line">                liquidity: cache.liquidityStart</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>只有还有剩余的input/output同时没有超过价格限制则正常进行交易操作，在这里示例化了一个StepComputations变量，该变量存储了交易过程中的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct StepComputations &#123;</span><br><span class="line">    // the price at the beginning of the step</span><br><span class="line">    uint160 sqrtPriceStartX96;</span><br><span class="line">    // the next tick to swap to from the current tick in the swap direction</span><br><span class="line">    int24 tickNext;</span><br><span class="line">    // whether tickNext is initialized or not</span><br><span class="line">    bool initialized;</span><br><span class="line">    // sqrt(price) for the next tick (1/0)</span><br><span class="line">    uint160 sqrtPriceNextX96;</span><br><span class="line">    // how much is being swapped in in this step</span><br><span class="line">    uint256 amountIn;</span><br><span class="line">    // how much is being swapped out</span><br><span class="line">    uint256 amountOut;</span><br><span class="line">    // how much fee is being paid in</span><br><span class="line">    uint256 feeAmount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后获取交易的起始价格，然后通过位图找到下一个可选的交易价格，这里的下一个可选的交易价格可能会到下一个流动性中，也可能还是在本流动性中，之后需要确保我们不会超过最小和最大tick，因为tick位图不知道这些边界：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// continue swapping as long as we haven&#x27;t used the entire input/output and haven&#x27;t reached the price limit</span><br><span class="line">while (state.amountSpecifiedRemaining != 0 &amp;&amp; state.sqrtPriceX96 != sqrtPriceLimitX96) &#123;</span><br><span class="line">    StepComputations memory step;</span><br><span class="line"></span><br><span class="line">    step.sqrtPriceStartX96 = state.sqrtPriceX96;</span><br><span class="line"></span><br><span class="line">    (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(</span><br><span class="line">        state.tick,</span><br><span class="line">        tickSpacing,</span><br><span class="line">        zeroForOne</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds</span><br><span class="line">    if (step.tickNext &lt; TickMath.MIN_TICK) &#123;</span><br><span class="line">        step.tickNext = TickMath.MIN_TICK;</span><br><span class="line">    &#125; else if (step.tickNext &gt; TickMath.MAX_TICK) &#123;</span><br><span class="line">        step.tickNext = TickMath.MAX_TICK;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之后获取下一个tick的价格，之后计算要交换目标价格、输入/输出量、费用等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// get the price for the next tick</span><br><span class="line">step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);</span><br><span class="line">        </span><br><span class="line">// compute values to swap to the target tick, price limit, or point where input/output amount is exhausted</span><br><span class="line">(state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(</span><br><span class="line">    state.sqrtPriceX96,</span><br><span class="line">    (zeroForOne ? step.sqrtPriceNextX96 &lt; sqrtPriceLimitX96 : step.sqrtPriceNextX96 &gt; sqrtPriceLimitX96)</span><br><span class="line">        ? sqrtPriceLimitX96</span><br><span class="line">        : step.sqrtPriceNextX96,</span><br><span class="line">    state.liquidity,</span><br><span class="line">    state.amountSpecifiedRemaining,</span><br><span class="line">    fee</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果exactInput为true则表示input不为负数，之后更新amountSpecifiedRemaining(剩余期望兑换的数量)与amountCalculated(已经兑换的数量)，如果exactInput为false则表示input为负数，之后更新amountSpecifiedRemaining(剩余期望兑换的数量)与amountCalculated(已经兑换的数量)，不过需要注意的是这里的符号有所变化，运算逻辑也有所改变，之后检查协议费用是否开启，如果开启则计算欠费多少，并减少feetAmount，增加protocolFee：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (exactInput) &#123;</span><br><span class="line">    state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();</span><br><span class="line">    state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    state.amountSpecifiedRemaining += step.amountOut.toInt256();</span><br><span class="line">    state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee</span><br><span class="line">if (cache.feeProtocol &gt; 0) &#123;</span><br><span class="line">    uint256 delta = step.feeAmount / cache.feeProtocol;</span><br><span class="line">    step.feeAmount -= delta;</span><br><span class="line">    state.protocolFee += uint128(delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// update global fee tracker</span><br><span class="line">if (state.liquidity &gt; 0)</span><br><span class="line">    state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);</span><br></pre></td></tr></table></figure>

<p>当更新到下一个价格时更新tick，检查tick是否已经初始化，如果是则进行tick过渡处理，具体的方法是检查占位符的值，并使用第一次穿过初始化刻度时的实际值来替换它，之后更新tick的值，如果tokenIn被耗尽，则直接计算当前价格对应的tick：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// shift tick if we reached the next price</span><br><span class="line">if (state.sqrtPriceX96 == step.sqrtPriceNextX96) &#123;</span><br><span class="line">    // if the tick is initialized, run the tick transition</span><br><span class="line">    if (step.initialized) &#123;</span><br><span class="line">        // check for the placeholder value, which we replace with the actual value the first time the swap</span><br><span class="line">        // crosses an initialized tick</span><br><span class="line">        if (!cache.computedLatestObservation) &#123;</span><br><span class="line">            (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(</span><br><span class="line">                cache.blockTimestamp,</span><br><span class="line">                0,</span><br><span class="line">                slot0Start.tick,</span><br><span class="line">                slot0Start.observationIndex,</span><br><span class="line">                cache.liquidityStart,</span><br><span class="line">                slot0Start.observationCardinality</span><br><span class="line">            );</span><br><span class="line">            cache.computedLatestObservation = true;</span><br><span class="line">        &#125;</span><br><span class="line">        int128 liquidityNet =</span><br><span class="line">            ticks.cross(</span><br><span class="line">                step.tickNext,</span><br><span class="line">                (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),</span><br><span class="line">                (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),</span><br><span class="line">                cache.secondsPerLiquidityCumulativeX128,</span><br><span class="line">                cache.tickCumulative,</span><br><span class="line">                cache.blockTimestamp</span><br><span class="line">            );</span><br><span class="line">        // if we&#x27;re moving leftward, we interpret liquidityNet as the opposite sign</span><br><span class="line">        // safe because liquidityNet cannot be type(int128).min</span><br><span class="line">        if (zeroForOne) liquidityNet = -liquidityNet;</span><br><span class="line"></span><br><span class="line">        state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;</span><br><span class="line">&#125; else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) &#123;</span><br><span class="line">    // recompute unless we&#x27;re on a lower tick boundary (i.e. already transitioned ticks), and haven&#x27;t moved</span><br><span class="line">    state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 之后当tick改变时写入一个oracle条目，否则只更新价格，如果流动性发生变化则更新流动性，以及更新费用等，最后进行转账和费用收取操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    // update tick and write an oracle entry if the tick change</span><br><span class="line">    if (state.tick != slot0Start.tick) &#123;</span><br><span class="line">        (uint16 observationIndex, uint16 observationCardinality) =</span><br><span class="line">            observations.write(</span><br><span class="line">                slot0Start.observationIndex,</span><br><span class="line">                cache.blockTimestamp,</span><br><span class="line">                slot0Start.tick,</span><br><span class="line">                cache.liquidityStart,</span><br><span class="line">                slot0Start.observationCardinality,</span><br><span class="line">                slot0Start.observationCardinalityNext</span><br><span class="line">            );</span><br><span class="line">        (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (</span><br><span class="line">            state.sqrtPriceX96,</span><br><span class="line">            state.tick,</span><br><span class="line">            observationIndex,</span><br><span class="line">            observationCardinality</span><br><span class="line">        );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // otherwise just update the price</span><br><span class="line">        slot0.sqrtPriceX96 = state.sqrtPriceX96;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // update liquidity if it changed</span><br><span class="line">    if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;</span><br><span class="line"></span><br><span class="line">    // update fee growth global and, if necessary, protocol fees</span><br><span class="line">    // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees</span><br><span class="line">    if (zeroForOne) &#123;</span><br><span class="line">        feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;</span><br><span class="line">        if (state.protocolFee &gt; 0) protocolFees.token0 += state.protocolFee;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;</span><br><span class="line">        if (state.protocolFee &gt; 0) protocolFees.token1 += state.protocolFee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (amount0, amount1) = zeroForOne == exactInput</span><br><span class="line">        ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)</span><br><span class="line">        : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);</span><br><span class="line"></span><br><span class="line">    // do the transfers and collect payment</span><br><span class="line">    if (zeroForOne) &#123;</span><br><span class="line">        if (amount1 &lt; 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));</span><br><span class="line"></span><br><span class="line">        uint256 balance0Before = balance0();</span><br><span class="line">        IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);</span><br><span class="line">        require(balance0Before.add(uint256(amount0)) &lt;= balance0(), &#x27;IIA&#x27;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (amount0 &lt; 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));</span><br><span class="line"></span><br><span class="line">        uint256 balance1Before = balance1();</span><br><span class="line">        IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);</span><br><span class="line">        require(balance1Before.add(uint256(amount1)) &lt;= balance1(), &#x27;IIA&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);</span><br><span class="line">    slot0.unlocked = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h4><p>flash函数主要用于实现闪电贷，相关参数说明如下：</p>
<ul>
<li>recipient - 想借token的用户地址,比如可以是用户自己开发的合约的地址</li>
<li>amount0 - 用户想借入的token0数量</li>
<li>amount1 - 用户想借入的token1数量</li>
<li>data - 回调函数参数</li>
</ul>
<p>在该函数中首先计算借贷需要扣除的手续费，之后记录当前的余额，之后将借贷的token发送给借贷方，之后调用借贷方地址的回调函数将用户传入的data参数传递给该回调函数，之后再次记录调用完后的余额，之后检查回调函数调用完后余额的数量，每一个token的余额只可多不可少，之后计算借出的token0与token1的数量以及费用等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3PoolActions</span><br><span class="line">function flash(</span><br><span class="line">    address recipient,</span><br><span class="line">    uint256 amount0,</span><br><span class="line">    uint256 amount1,</span><br><span class="line">    bytes calldata data</span><br><span class="line">) external override lock noDelegateCall &#123;</span><br><span class="line">    uint128 _liquidity = liquidity;</span><br><span class="line">    require(_liquidity &gt; 0, &#x27;L&#x27;);</span><br><span class="line"></span><br><span class="line">    uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6); //用户需要支付的借贷手续费</span><br><span class="line">    uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6); //用户需要支付的借贷手续费</span><br><span class="line">    uint256 balance0Before = balance0(); //借贷前的金额</span><br><span class="line">    uint256 balance1Before = balance1(); //借贷前的金额</span><br><span class="line">    if (amount0 &gt; 0) TransferHelper.safeTransfer(token0, recipient, amount0); //借出token给用户</span><br><span class="line">    if (amount1 &gt; 0) TransferHelper.safeTransfer(token1, recipient, amount1); //借出token给用户</span><br><span class="line">    IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data); //用户应该自己开发合约并实现此回调函数,注意参数是需要支付的手续费数量</span><br><span class="line">    uint256 balance0After = balance0(); //用户已经连本带利归还后的余额</span><br><span class="line">    uint256 balance1After = balance1(); //用户已经连本带利归还后的余额</span><br><span class="line">    require(balance0Before.add(fee0) &lt;= balance0After, &#x27;F0&#x27;); //检查用户是不是已经连本带利足额还款, 没还就回滚整个交易</span><br><span class="line">    require(balance1Before.add(fee1) &lt;= balance1After, &#x27;F1&#x27;); //检查用户是不是已经连本带利足额还款, 没还就回滚整个交易</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // sub is safe because we know balanceAfter is gt balanceBefore by at least fee</span><br><span class="line">    uint256 paid0 = balance0After - balance0Before;</span><br><span class="line">    uint256 paid1 = balance1After - balance1Before;</span><br><span class="line"></span><br><span class="line">    if (paid0 &gt; 0) &#123;</span><br><span class="line">        uint8 feeProtocol0 = slot0.feeProtocol % 16;</span><br><span class="line">        uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;</span><br><span class="line">        if (uint128(fees0) &gt; 0) protocolFees.token0 += uint128(fees0);</span><br><span class="line">        feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);</span><br><span class="line">    &#125;</span><br><span class="line">    if (paid1 &gt; 0) &#123;</span><br><span class="line">        uint8 feeProtocol1 = slot0.feeProtocol &gt;&gt; 4;</span><br><span class="line">        uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;</span><br><span class="line">        if (uint128(fees1) &gt; 0) protocolFees.token1 += uint128(fees1);</span><br><span class="line">        feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProtocalFee"><a href="#ProtocalFee" class="headerlink" title="ProtocalFee"></a>ProtocalFee</h4><p>一般没人用似乎。</p>
<p>setFeeProtocol用于设置协议的费用份额的分母，相关参数说明如下：</p>
<ul>
<li>feeProtocol0：池中token0的新协议费用</li>
<li>feeProtocol1：池中token1的新协议费用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3PoolOwnerActions</span><br><span class="line">function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner &#123;</span><br><span class="line">    require(</span><br><span class="line">        (feeProtocol0 == 0 || (feeProtocol0 &gt;= 4 &amp;&amp; feeProtocol0 &lt;= 10)) &amp;&amp;</span><br><span class="line">            (feeProtocol1 == 0 || (feeProtocol1 &gt;= 4 &amp;&amp; feeProtocol1 &lt;= 10))</span><br><span class="line">    );</span><br><span class="line">    uint8 feeProtocolOld = slot0.feeProtocol;</span><br><span class="line">    slot0.feeProtocol = feeProtocol0 + (feeProtocol1 &lt;&lt; 4);</span><br><span class="line">    emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld &gt;&gt; 4, feeProtocol0, feeProtocol1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>collectProtocol函数用于收取协议费用，相关参数说明如下：</p>
<ul>
<li>recipient：接受协议费用的地址</li>
<li>amount0Requested：在token0中收取的协议费用</li>
<li>amount1Requested：在token1中收取的协议费用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3PoolOwnerActions</span><br><span class="line">function collectProtocol(</span><br><span class="line">    address recipient,</span><br><span class="line">    uint128 amount0Requested,</span><br><span class="line">    uint128 amount1Requested</span><br><span class="line">) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) &#123;</span><br><span class="line">    amount0 = amount0Requested &gt; protocolFees.token0 ? protocolFees.token0 : amount0Requested;</span><br><span class="line">    amount1 = amount1Requested &gt; protocolFees.token1 ? protocolFees.token1 : amount1Requested;</span><br><span class="line"></span><br><span class="line">    if (amount0 &gt; 0) &#123;</span><br><span class="line">        if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings</span><br><span class="line">        protocolFees.token0 -= amount0;</span><br><span class="line">        TransferHelper.safeTransfer(token0, recipient, amount0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (amount1 &gt; 0) &#123;</span><br><span class="line">        if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings</span><br><span class="line">        protocolFees.token1 -= amount1;</span><br><span class="line">        TransferHelper.safeTransfer(token1, recipient, amount1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit CollectProtocol(msg.sender, recipient, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h4><p>snapshotCumulativesInside函数用于返回分时累计的快照、每个流动性的秒数和分时范围内的秒数，快照只能与其他快照进行比较，这些快照在头寸存在的时间段内拍摄，如果在拍摄第一个快照和拍摄第二个快照之间的整个时间段内没有持有仓位，则无法比较快照，相关参数如下：</p>
<ul>
<li>tickLower：范围下限</li>
<li>tickUpper：范围上限 </li>
</ul>
<p>返回值说明：</p>
<ul>
<li>tickCumulativeInside：对应范围的刻度累加器的快照</li>
<li>secondsPerLiquidityInsideX128：范围内每个流动性的秒数快照 </li>
<li>secondsInside：范围内每个流动性的秒数快照</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3PoolDerivedState</span><br><span class="line">function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    override</span><br><span class="line">    noDelegateCall</span><br><span class="line">    returns (</span><br><span class="line">        int56 tickCumulativeInside,</span><br><span class="line">        uint160 secondsPerLiquidityInsideX128,</span><br><span class="line">        uint32 secondsInside</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    checkTicks(tickLower, tickUpper);</span><br><span class="line"></span><br><span class="line">    int56 tickCumulativeLower;</span><br><span class="line">    int56 tickCumulativeUpper;</span><br><span class="line">    uint160 secondsPerLiquidityOutsideLowerX128;</span><br><span class="line">    uint160 secondsPerLiquidityOutsideUpperX128;</span><br><span class="line">    uint32 secondsOutsideLower;</span><br><span class="line">    uint32 secondsOutsideUpper;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Tick.Info storage lower = ticks[tickLower];</span><br><span class="line">        Tick.Info storage upper = ticks[tickUpper];</span><br><span class="line">        bool initializedLower;</span><br><span class="line">        (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (</span><br><span class="line">            lower.tickCumulativeOutside,</span><br><span class="line">            lower.secondsPerLiquidityOutsideX128,</span><br><span class="line">            lower.secondsOutside,</span><br><span class="line">            lower.initialized</span><br><span class="line">        );</span><br><span class="line">        require(initializedLower);</span><br><span class="line"></span><br><span class="line">        bool initializedUpper;</span><br><span class="line">        (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (</span><br><span class="line">            upper.tickCumulativeOutside,</span><br><span class="line">            upper.secondsPerLiquidityOutsideX128,</span><br><span class="line">            upper.secondsOutside,</span><br><span class="line">            upper.initialized</span><br><span class="line">        );</span><br><span class="line">        require(initializedUpper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slot0 memory _slot0 = slot0;</span><br><span class="line"></span><br><span class="line">    if (_slot0.tick &lt; tickLower) &#123;</span><br><span class="line">        return (</span><br><span class="line">            tickCumulativeLower - tickCumulativeUpper,</span><br><span class="line">            secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,</span><br><span class="line">            secondsOutsideLower - secondsOutsideUpper</span><br><span class="line">        );</span><br><span class="line">    &#125; else if (_slot0.tick &lt; tickUpper) &#123;</span><br><span class="line">        uint32 time = _blockTimestamp();</span><br><span class="line">        (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) =</span><br><span class="line">            observations.observeSingle(</span><br><span class="line">                time,</span><br><span class="line">                0,</span><br><span class="line">                _slot0.tick,</span><br><span class="line">                _slot0.observationIndex,</span><br><span class="line">                liquidity,</span><br><span class="line">                _slot0.observationCardinality</span><br><span class="line">            );</span><br><span class="line">        return (</span><br><span class="line">            tickCumulative - tickCumulativeLower - tickCumulativeUpper,</span><br><span class="line">            secondsPerLiquidityCumulativeX128 -</span><br><span class="line">                secondsPerLiquidityOutsideLowerX128 -</span><br><span class="line">                secondsPerLiquidityOutsideUpperX128,</span><br><span class="line">            time - secondsOutsideLower - secondsOutsideUpper</span><br><span class="line">        );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (</span><br><span class="line">            tickCumulativeUpper - tickCumulativeLower,</span><br><span class="line">            secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,</span><br><span class="line">            secondsOutsideUpper - secondsOutsideLower</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>observe函数用于请求前N秒之前的历史数据，这里的参数secondsAgos为一个动态数组，故而可以一次请求多个历史数据，返回变量tickCumulatives和 liquidityCumulatives也是动态数组，用于记录请求参数中对应时间戳的tick index累积值和流动性累积值，之后调用observations.observe()处理数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    /// @inheritdoc IUniswapV3PoolDerivedState</span><br><span class="line">    function observe(uint32[] calldata secondsAgos)</span><br><span class="line">        external</span><br><span class="line">        view</span><br><span class="line">        override</span><br><span class="line">        noDelegateCall</span><br><span class="line">        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)</span><br><span class="line">&#123;</span><br><span class="line">        return</span><br><span class="line">            observations.observe(</span><br><span class="line">                _blockTimestamp(),</span><br><span class="line">                secondsAgos,</span><br><span class="line">                slot0.tick,</span><br><span class="line">                slot0.observationIndex,</span><br><span class="line">                liquidity,</span><br><span class="line">                slot0.observationCardinality</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>observe代码如下所示，该函数通过遍历请求参数获取每一个请求时间点的Oracle数据，数据获取通过observeSingle来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`</span><br><span class="line">/// @dev Reverts if `secondsAgos` &gt; oldest observation</span><br><span class="line">/// @param self The stored oracle array</span><br><span class="line">/// @param time The current block.timestamp</span><br><span class="line">/// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation</span><br><span class="line">/// @param tick The current tick</span><br><span class="line">/// @param index The index of the observation that was most recently written to the observations array</span><br><span class="line">/// @param liquidity The current in-range pool liquidity</span><br><span class="line">/// @param cardinality The number of populated elements in the oracle array</span><br><span class="line">/// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`</span><br><span class="line">/// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`</span><br><span class="line">function observe(</span><br><span class="line">    Observation[65535] storage self,</span><br><span class="line">    uint32 time,</span><br><span class="line">    uint32[] memory secondsAgos,</span><br><span class="line">    int24 tick,</span><br><span class="line">    uint16 index,</span><br><span class="line">    uint128 liquidity,</span><br><span class="line">    uint16 cardinality</span><br><span class="line">) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) &#123;</span><br><span class="line">    require(cardinality &gt; 0, &#x27;I&#x27;);</span><br><span class="line"></span><br><span class="line">    tickCumulatives = new int56[](secondsAgos.length);</span><br><span class="line">    secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);</span><br><span class="line">    for (uint256 i = 0; i &lt; secondsAgos.length; i++) &#123;</span><br><span class="line">        (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(</span><br><span class="line">            self,</span><br><span class="line">            time,</span><br><span class="line">            secondsAgos[i],</span><br><span class="line">            tick,</span><br><span class="line">            index,</span><br><span class="line">            liquidity,</span><br><span class="line">            cardinality</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外围合约"><a href="#外围合约" class="headerlink" title="外围合约"></a>外围合约</h2><h3 id="NonfungiblePositionManger合约"><a href="#NonfungiblePositionManger合约" class="headerlink" title="NonfungiblePositionManger合约"></a>NonfungiblePositionManger合约</h3><p>​    NonfungiblePositionManager合约是直接与链下前端进行交互的外围合约, 主要对外提供比如创建流动池, 添加流动性, 删除流动性等API接口, 同时也会为每个流动性仓位生成一个唯一的NFT给到用户, 可以说是Uniswap协议中最为重要的一个管理器，这里需要再次强调一下, 就是NonfungiblePositionManager合约可以同时管理多个流动池Pool(每个流动池包含一个交易对), 其由(token0,token1,fee)唯一标识, 而每个流动池又是一个流动性聚合器其同时包含多个流动性仓位, 而每个流动性仓位又可以由(owner,tickLower,tickUpper)唯一进行标识.</p>
<p>NonfungiblePositionManager合约对外提供一些重要的API:</p>
<ol>
<li><strong>createAndInitializePoolIfNecessary</strong>, 部署一个新的流动池合约</li>
<li><strong>selfPermitAllowed/selfPermit</strong>, 授权合约有转账相应token的权限</li>
<li><strong>mint</strong>, 给指定流动池添加一个新的流动性仓位, 并且生成一个代表此仓位的NFT给到用户</li>
<li><strong>increaseLiquidity</strong>, 给指定流动池某个已经存在的流动性仓位增加流动性</li>
<li><strong>decreaseLiquidity</strong>, 给指定流动池某个已经存在的流动性仓位减少流动性</li>
<li><strong>collect</strong>, 提取闲置token及其手续费</li>
<li><strong>multicall</strong>, 将多个合约调用打包进一次合约调用中, 这个其实是为了达到类似数据库事务(transaction)的效果, 一个事务应该满足:<ol>
<li>原子性(Atomicity): 事务中的全部操作在数据库中是不可分割的, 要么全部完成, 要么全部不执行</li>
<li>一致性(Consistency): 几个并行执行的事务, 其执行结果必须与按某一顺序串行执行的结果相一致</li>
<li>隔离性(Isolation): 事务的执行不受其他事务的干扰, 事务执行的中间结果对其他事务必须是透明的</li>
<li>持久性(Durability): 对于任意已提交事务, 系统必须保证该事务对数据库的改变不被丢失, 即使数据库出现故障</li>
</ol>
</li>
</ol>
<p>合约开头首先定义了相关数据结构，包括：position结构体、用于交易池ID检索的mapping、Pool Keys检索的mapping等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// details about the uniswap position</span><br><span class="line">struct Position &#123;</span><br><span class="line">    // the nonce for permits</span><br><span class="line">    uint96 nonce;</span><br><span class="line">    // the address that is approved for spending this token</span><br><span class="line">    address operator;</span><br><span class="line">    // the ID of the pool with which this token is connected</span><br><span class="line">    uint80 poolId;</span><br><span class="line">    // the tick range of the position</span><br><span class="line">    int24 tickLower;</span><br><span class="line">    int24 tickUpper;</span><br><span class="line">    // the liquidity of the position</span><br><span class="line">    uint128 liquidity;</span><br><span class="line">    // the fee growth of the aggregate position as of the last action on the individual position</span><br><span class="line">    uint256 feeGrowthInside0LastX128;</span><br><span class="line">    uint256 feeGrowthInside1LastX128;</span><br><span class="line">    // how many uncollected tokens are owed to the position, as of the last computation</span><br><span class="line">    uint128 tokensOwed0;</span><br><span class="line">    uint128 tokensOwed1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// @dev IDs of pools assigned by this contract</span><br><span class="line">mapping(address =&gt; uint80) private _poolIds;</span><br><span class="line"></span><br><span class="line">/// @dev Pool keys by pool ID, to save on SSTOREs for position data</span><br><span class="line">mapping(uint80 =&gt; PoolAddress.PoolKey) private _poolIdToPoolKey;</span><br><span class="line"></span><br><span class="line">/// @dev The token ID position data</span><br><span class="line">mapping(uint256 =&gt; Position) private _positions;</span><br><span class="line"></span><br><span class="line">/// @dev The ID of the next token that will be minted. Skips 0</span><br><span class="line">uint176 private _nextId = 1;</span><br><span class="line">/// @dev The ID of the next pool that is used for the first time. Skips 0</span><br><span class="line">uint80 private _nextPoolId = 1;</span><br><span class="line"></span><br><span class="line">/// @dev The address of the token descriptor contract, which handles generating token URIs for position tokens</span><br><span class="line">address private immutable _tokenDescriptor;</span><br></pre></td></tr></table></figure>

<p>构造函数进行初始化操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    constructor(</span><br><span class="line">        address _factory,</span><br><span class="line">        address _WETH9,</span><br><span class="line">        address _tokenDescriptor_</span><br><span class="line">) ERC721Permit(&#x27;Uniswap V3 Positions NFT-V1&#x27;, &#x27;UNI-V3-POS&#x27;, &#x27;1&#x27;) PeripheryImmutableState(_factory, _WETH9) &#123;</span><br><span class="line">        _tokenDescriptor = _tokenDescriptor_;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>positions用于检索与tokenid相关position信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc INonfungiblePositionManager</span><br><span class="line">function positions(uint256 tokenId)</span><br><span class="line">    external</span><br><span class="line">    view</span><br><span class="line">    override</span><br><span class="line">    returns (</span><br><span class="line">        uint96 nonce,</span><br><span class="line">        address operator,</span><br><span class="line">        address token0,</span><br><span class="line">        address token1,</span><br><span class="line">        uint24 fee,</span><br><span class="line">        int24 tickLower,</span><br><span class="line">        int24 tickUpper,</span><br><span class="line">        uint128 liquidity,</span><br><span class="line">        uint256 feeGrowthInside0LastX128,</span><br><span class="line">        uint256 feeGrowthInside1LastX128,</span><br><span class="line">        uint128 tokensOwed0,</span><br><span class="line">        uint128 tokensOwed1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    Position memory position = _positions[tokenId];</span><br><span class="line">    require(position.poolId != 0, &#x27;Invalid token ID&#x27;);</span><br><span class="line">    PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];</span><br><span class="line">    return (</span><br><span class="line">        position.nonce,</span><br><span class="line">        position.operator,</span><br><span class="line">        poolKey.token0,</span><br><span class="line">        poolKey.token1,</span><br><span class="line">        poolKey.fee,</span><br><span class="line">        position.tickLower,</span><br><span class="line">        position.tickUpper,</span><br><span class="line">        position.liquidity,</span><br><span class="line">        position.feeGrowthInside0LastX128,</span><br><span class="line">        position.feeGrowthInside1LastX128,</span><br><span class="line">        position.tokensOwed0,</span><br><span class="line">        position.tokensOwed1</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mint-1"><a href="#Mint-1" class="headerlink" title="Mint"></a>Mint</h4><p>mint函数给指定流动池添加一个新的流动性仓位, 并且生成一个代表此仓位的NFT给到用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function mint(MintParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (</span><br><span class="line">        uint256 tokenId,</span><br><span class="line">        uint128 liquidity,</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    IUniswapV3Pool pool;</span><br><span class="line">    (liquidity, amount0, amount1, pool) = addLiquidity( //此函数内部真正添加流动性,并完成token的转账充值</span><br><span class="line">        AddLiquidityParams(&#123;</span><br><span class="line">            token0: params.token0, //唯一标识一个流动池</span><br><span class="line">            token1: params.token1, //唯一标识一个流动池</span><br><span class="line">            fee: params.fee, //唯一标识一个流动池</span><br><span class="line">            recipient: address(this), //唯一标识该池中的一个流动性仓位</span><br><span class="line">            tickLower: params.tickLower, //唯一标识该池中的一个流动性仓位</span><br><span class="line">            tickUpper: params.tickUpper, //唯一标识该池中的一个流动性仓位</span><br><span class="line">            amount0Desired: params.amount0Desired, //要充值的token0数量</span><br><span class="line">            amount1Desired: params.amount1Desired, //要充值的token1数量</span><br><span class="line">            amount0Min: params.amount0Min,</span><br><span class="line">            amount1Min: params.amount1Min</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">    _mint(params.recipient, (tokenId = _nextId++)); //生成一个代表流动性仓位的NFT给到用户</span><br><span class="line">    bytes32 positionKey = PositionKey.compute(address(this), params.tickLower, params.tickUpper);</span><br><span class="line">    (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);</span><br><span class="line">    // idempotent set</span><br><span class="line">    uint80 poolId =</span><br><span class="line">        cachePoolKey(</span><br><span class="line">            address(pool),</span><br><span class="line">            PoolAddress.PoolKey(&#123;token0: params.token0, token1: params.token1, fee: params.fee&#125;)</span><br><span class="line">        );</span><br><span class="line">    _positions[tokenId] = Position(&#123; //将NFT与对应的流动性仓位进行关联</span><br><span class="line">        nonce: 0,</span><br><span class="line">        operator: address(0),</span><br><span class="line">        poolId: poolId, //该NFT所代表的流动性仓位属于哪个流动池</span><br><span class="line">        tickLower: params.tickLower, //该NFT所代表的流动性仓位做市区间最低点位</span><br><span class="line">        tickUpper: params.tickUpper, //该NFT所代表的流动性仓位做市区间最高点位</span><br><span class="line">        liquidity: liquidity, //该NFT所代表的流动性仓位的流动性大小, 也就是L值</span><br><span class="line">        feeGrowthInside0LastX128: feeGrowthInside0LastX128, //计算手续费相关</span><br><span class="line">        feeGrowthInside1LastX128: feeGrowthInside1LastX128, //计算手续费相关</span><br><span class="line">        tokensOwed0: 0,</span><br><span class="line">        tokensOwed1: 0</span><br><span class="line">    &#125;);</span><br><span class="line">    emit IncreaseLiquidity(tokenId, liquidity, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tokenURI函数用于为position管理者生成描述特定TokenID的URI(源自ERC721):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function tokenURI(uint256 tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) &#123;</span><br><span class="line">    require(_exists(tokenId));</span><br><span class="line">    return INonfungibleTokenPositionDescriptor(_tokenDescriptor).tokenURI(this, tokenId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Burn-1"><a href="#Burn-1" class="headerlink" title="Burn"></a>Burn</h4><p>burn函数用于销毁TokenID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc INonfungiblePositionManager</span><br><span class="line">function burn(uint256 tokenId) external payable override isAuthorizedForToken(tokenId) &#123;</span><br><span class="line">    Position storage position = _positions[tokenId];</span><br><span class="line">    require(position.liquidity == 0 &amp;&amp; position.tokensOwed0 == 0 &amp;&amp; position.tokensOwed1 == 0, &#x27;Not cleared&#x27;);</span><br><span class="line">    delete _positions[tokenId];</span><br><span class="line">    _burn(tokenId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="increaseLiquidity"><a href="#increaseLiquidity" class="headerlink" title="increaseLiquidity"></a>increaseLiquidity</h4><p>increaseLiquidity函数用于给指定流动池某个已经存在的流动性仓位增加流动性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function increaseLiquidity(IncreaseLiquidityParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (</span><br><span class="line">        uint128 liquidity,</span><br><span class="line">        uint256 amount0,</span><br><span class="line">        uint256 amount1</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    Position storage position = _positions[params.tokenId]; //根据传入的 NFT id 获取对应的流动性仓位信息</span><br><span class="line">    PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId]; //获取该流动性仓位所属的流动池</span><br><span class="line">    IUniswapV3Pool pool;</span><br><span class="line">    (liquidity, amount0, amount1, pool) = addLiquidity( //向该流动池添加流动性, 不在赘述</span><br><span class="line">        AddLiquidityParams(&#123;</span><br><span class="line">            token0: poolKey.token0,</span><br><span class="line">            token1: poolKey.token1,</span><br><span class="line">            fee: poolKey.fee,</span><br><span class="line">            tickLower: position.tickLower,</span><br><span class="line">            tickUpper: position.tickUpper,</span><br><span class="line">            amount0Desired: params.amount0Desired,</span><br><span class="line">            amount1Desired: params.amount1Desired,</span><br><span class="line">            amount0Min: params.amount0Min,</span><br><span class="line">            amount1Min: params.amount1Min,</span><br><span class="line">            recipient: address(this)</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">    bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper);</span><br><span class="line">    // this is now updated to the current transaction</span><br><span class="line">    (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey); //获取该流动池中对应的这个流动性仓位</span><br><span class="line">    position.tokensOwed0 += uint128( //更新这个流动性仓位之前获取的做市手续费</span><br><span class="line">        FullMath.mulDiv(</span><br><span class="line">            feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,</span><br><span class="line">            position.liquidity,</span><br><span class="line">            FixedPoint128.Q128</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    position.tokensOwed1 += uint128( //更新这个流动性仓位之前获取的做市手续费</span><br><span class="line">        FullMath.mulDiv(</span><br><span class="line">            feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,</span><br><span class="line">            position.liquidity,</span><br><span class="line">            FixedPoint128.Q128</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128; //更新手续费计算相关</span><br><span class="line">    position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128; //更新手续费计算相关</span><br><span class="line">    position.liquidity += liquidity; //更新L值</span><br><span class="line">    emit IncreaseLiquidity(params.tokenId, liquidity, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="decreaseLiquidity"><a href="#decreaseLiquidity" class="headerlink" title="decreaseLiquidity"></a>decreaseLiquidity</h4><p>decreaseLiquidity函数用于给指定流动池某个已经存在的流动性仓位减少流动性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function decreaseLiquidity(DecreaseLiquidityParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    isAuthorizedForToken(params.tokenId)</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (uint256 amount0, uint256 amount1)</span><br><span class="line">&#123;</span><br><span class="line">    require(params.liquidity &gt; 0);</span><br><span class="line">    Position storage position = _positions[params.tokenId]; //根据传入的 NFT id 获取对应的流动性仓位信息</span><br><span class="line">    uint128 positionLiquidity = position.liquidity;</span><br><span class="line">    require(positionLiquidity &gt;= params.liquidity);</span><br><span class="line">    PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId]; //获取该流动性仓位所属的流动池key</span><br><span class="line">    IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey)); //获取该流动性仓位所属的流动池合约地址</span><br><span class="line">    (amount0, amount1) = pool.burn(position.tickLower, position.tickUpper, params.liquidity); //调用该流动池合约的burn函数,真正完成减少流动性</span><br><span class="line">    require(amount0 &gt;= params.amount0Min &amp;&amp; amount1 &gt;= params.amount1Min, &#x27;Price slippage check&#x27;);</span><br><span class="line">    bytes32 positionKey = PositionKey.compute(address(this), position.tickLower, position.tickUpper); //获取该流动性仓位的key</span><br><span class="line">    // this is now updated to the current transaction</span><br><span class="line">    (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey); //从指定流动池中获取该流动性仓位的手续费相关信息</span><br><span class="line">    position.tokensOwed0 +=</span><br><span class="line">        uint128(amount0) +</span><br><span class="line">        uint128(</span><br><span class="line">            FullMath.mulDiv(</span><br><span class="line">                feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,</span><br><span class="line">                positionLiquidity,</span><br><span class="line">                FixedPoint128.Q128</span><br><span class="line">            )</span><br><span class="line">        ); //减少流动性后,会空闲出多余token,记录之,同时也会更新之前的做市手续费收入</span><br><span class="line">    position.tokensOwed1 +=</span><br><span class="line">        uint128(amount1) +</span><br><span class="line">        uint128(</span><br><span class="line">            FullMath.mulDiv(</span><br><span class="line">                feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,</span><br><span class="line">                positionLiquidity,</span><br><span class="line">                FixedPoint128.Q128</span><br><span class="line">            )</span><br><span class="line">        ); //减少流动性后,会空闲出多余token,记录之,同时也会更新之前的做市手续费收入</span><br><span class="line">    position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128; //更新手续费计算相关</span><br><span class="line">    position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128; //更新手续费计算相关</span><br><span class="line">    // subtraction is safe because we checked positionLiquidity is gte params.liquidity</span><br><span class="line">    position.liquidity = positionLiquidity - params.liquidity; //更新L值</span><br><span class="line">    emit DecreaseLiquidity(params.tokenId, params.liquidity, amount0, amount1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>collect函数用于提取闲置token及其手续费</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function collect(CollectParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    isAuthorizedForToken(params.tokenId)</span><br><span class="line">    returns (uint256 amount0, uint256 amount1)</span><br><span class="line">&#123;</span><br><span class="line">    require(params.amount0Max &gt; 0 || params.amount1Max &gt; 0);</span><br><span class="line">    // allow collecting to the nft position manager address with address 0</span><br><span class="line">    address recipient = params.recipient == address(0) ? address(this) : params.recipient;</span><br><span class="line">    Position storage position = _positions[params.tokenId]; //根据传入的 NFT id 获取对应的流动性仓位信息</span><br><span class="line">    PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId]; //根据流动性仓位信息找所属的流动池</span><br><span class="line">    IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey)); //获取该流动池合约地址</span><br><span class="line">    (uint128 tokensOwed0, uint128 tokensOwed1) = (position.tokensOwed0, position.tokensOwed1); //真正可提取的token数量</span><br><span class="line">    // trigger an update of the position fees owed and fee growth snapshots if it has any liquidity</span><br><span class="line">    if (position.liquidity &gt; 0) &#123;</span><br><span class="line">        pool.burn(position.tickLower, position.tickUpper, 0); //这里并不是减少流动性,而仅仅只是为了更新手续费</span><br><span class="line">        (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) =</span><br><span class="line">            pool.positions(PositionKey.compute(address(this), position.tickLower, position.tickUpper));</span><br><span class="line">        tokensOwed0 += uint128(</span><br><span class="line">            FullMath.mulDiv(</span><br><span class="line">                feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,</span><br><span class="line">                position.liquidity,</span><br><span class="line">                FixedPoint128.Q128</span><br><span class="line">            )</span><br><span class="line">        ); //把最新的可提取的手续费收入也累加进来</span><br><span class="line">        tokensOwed1 += uint128(</span><br><span class="line">            FullMath.mulDiv(</span><br><span class="line">                feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,</span><br><span class="line">                position.liquidity,</span><br><span class="line">                FixedPoint128.Q128</span><br><span class="line">            )</span><br><span class="line">        ); //把最新的可提取的手续费收入也累加进来</span><br><span class="line">        position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;</span><br><span class="line">        position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;</span><br><span class="line">    &#125;</span><br><span class="line">    // compute the arguments to give to the pool#collect method</span><br><span class="line">    (uint128 amount0Collect, uint128 amount1Collect) =</span><br><span class="line">        (</span><br><span class="line">            params.amount0Max &gt; tokensOwed0 ? tokensOwed0 : params.amount0Max,</span><br><span class="line">            params.amount1Max &gt; tokensOwed1 ? tokensOwed1 : params.amount1Max</span><br><span class="line">        );</span><br><span class="line">    // the actual amounts collected are returned</span><br><span class="line">    (amount0, amount1) = pool.collect( //调用流动池合约的collect函数,真正完成转账提取token的操作</span><br><span class="line">        recipient, //用户收钱地址</span><br><span class="line">        position.tickLower, //用于标识对应的流动性仓位</span><br><span class="line">        position.tickUpper, //用于标识对应的流动性仓位</span><br><span class="line">        amount0Collect, //期望提取的token数量</span><br><span class="line">        amount1Collect  //期望提取的token数量</span><br><span class="line">    );</span><br><span class="line">    // sometimes there will be a few less wei than expected due to rounding down in core, but we just subtract the full amount expected</span><br><span class="line">    // instead of the actual amount so we can burn the token</span><br><span class="line">    (position.tokensOwed0, position.tokensOwed1) = (tokensOwed0 - amount0Collect, tokensOwed1 - amount1Collect);</span><br><span class="line">    emit Collect(params.tokenId, recipient, amount0Collect, amount1Collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="muticall"><a href="#muticall" class="headerlink" title="muticall"></a>muticall</h4><p>multicall, 将多个合约调用打包进一次合约调用中, 这是事务性的关键操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function multicall(bytes[] calldata data) external payable override returns (bytes[] memory results) &#123;</span><br><span class="line">    results = new bytes[](data.length);</span><br><span class="line">    for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        (bool success, bytes memory result) = address(this).delegatecall(data[i]);</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            // Next 5 lines from https://ethereum.stackexchange.com/a/83577</span><br><span class="line">            if (result.length &lt; 68) revert();</span><br><span class="line">            assembly &#123;</span><br><span class="line">                result := add(result, 0x04)</span><br><span class="line">            &#125;</span><br><span class="line">            revert(abi.decode(result, (string)));</span><br><span class="line">        &#125;</span><br><span class="line">        results[i] = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到逻辑其实很简单, 就是在一个for循环中依次调用之前打包的各个合约调用, 这里有一个非常关键的技术要点就是delegatecall, delegatecall的作用是当用户A通过合约B来delegatecall合约C的时候, 执行的是合约C的函数, 但是语境仍是合约B的: msg.sender是A的地址, 并且如果函数改变一些状态变量, 产生的效果会作用于合约B的变量上, 如下图:</p>
<p><img src="https://pic1.zhimg.com/80/v2-3846ce5ac5e1c16279a891c373a696c0_720w.webp" alt="img"></p>
<h3 id="SWAPROUTER合约"><a href="#SWAPROUTER合约" class="headerlink" title="SWAPROUTER合约"></a>SWAPROUTER合约</h3><p>SwapRouter合约是直接与链下前端进行交互的外围合约, 主要对外交易兑换功能, 此合约可以看成用户的交易代理合约, 可以协助用户完成一些相对复杂的兑换操作, 用户&lt;==&gt;SwapRouter合约&lt;==&gt;UniswapV3Pool合约SwapRouter合约主要封装了四个与交易相关的API接口对外提供服务, 分别是:</p>
<ol>
<li><p><strong>exactInputSingle</strong>: 两个token之间进行兑换, 已知输入token的数量, 输出token的数量函数内部会自动进行计算</p>
</li>
<li><p><strong>exactInput</strong>: 两个token之间进行兑换, 已知输入token的数量, 支持复杂路径, 比如ETH-&gt;DAI, 可以直接在ETH/DAI流动池兑换, 也可以利用ETH-&gt;USDC-&gt;DAI这个路径, 通过ETH/USDC, USDC/DAI两个流动池接力完成兑换, 至于采取哪个路径, 由链下前端决定, 链下前端会根据情况计算出最优路径.</p>
</li>
<li><p><strong>exactOutputSingle</strong>: 两个token之间进行兑换, 已知输出token的数量, 输入token的数量函数内部会自动进行计算</p>
</li>
<li><p><strong>exactOutput</strong>: 两个token之间进行兑换, 已知输出token的数量, 支持复杂路径(实际并没有实现)</p>
</li>
</ol>
<p>需要说明的是：</p>
<ol>
<li>当创建流动池的时候就已经确保了池内的token0地址小于token1地址, 所以当用户想用tokenIn兑换tokenOut的时候, 也就是tokenIn=&gt;tokenOut, 那么需要判断它俩地址的大小, 当tokenIn&lt;tokenOut的时候, tokenIn等于池内的token0, tokenOut等于池内的token1, 也就是token0=&gt;token1. 当tokenIn&gt;tokenOut的时候, tokenIn等于池内的token1, tokenOut等于池内的token0, 也就是token1=&gt;token0</li>
<li>对于每一个流动池, 池内的token0是基础货币, token1是计价货币, 池内的价格指的是token0的价格, 以token1计价, 所以用token0兑换token1(token0=&gt;token1), 可以理解为卖出操作, 对于卖出而言, sqrtPriceLimitX96指的是可以接受的最低卖出价格. 而用token1兑换token0(token1=&gt;token0), 可以理解为买入操作, 对于买入而言, sqrtPriceLimitX96指的是可以接受的最高买入价格. 最后需要再次强调的是一个交易对在流动池里面只会以交易对中两个token合约地址大小来确定顺序, 而不会考虑日常的习惯, 比如交易对LINK/USDT, 假如LINK合约地址大于USDT合约地址, 那么它们在流动池里面实际是USDT/LINK, 也就是说token0是USDT, token1是LINK.</li>
</ol>
<h4 id="getpool"><a href="#getpool" class="headerlink" title="getpool"></a>getpool</h4><p>getPool函数用于根据tokenA、TokenB以及fee来获取对应的池子信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    /// @dev Returns the pool for the given token pair and fee. The pool contract may or may not exist.</span><br><span class="line">    function getPool(</span><br><span class="line">        address tokenA,</span><br><span class="line">        address tokenB,</span><br><span class="line">        uint24 fee</span><br><span class="line">) private view returns (IUniswapV3Pool) &#123;</span><br><span class="line">        return IUniswapV3Pool(PoolAddress.computeAddress(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="SwapCallBack"><a href="#SwapCallBack" class="headerlink" title="SwapCallBack"></a>SwapCallBack</h4><p>uniswapV3SwapCallback函数用于回调操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc IUniswapV3SwapCallback</span><br><span class="line">    function uniswapV3SwapCallback(</span><br><span class="line">        int256 amount0Delta,</span><br><span class="line">        int256 amount1Delta,</span><br><span class="line">        bytes calldata _data</span><br><span class="line">    ) external override &#123;</span><br><span class="line">        require(amount0Delta &gt; 0 || amount1Delta &gt; 0); // swaps entirely within 0-liquidity regions are not supported</span><br><span class="line">        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));</span><br><span class="line">        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();</span><br><span class="line">        CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);</span><br><span class="line">        (bool isExactInput, uint256 amountToPay) =</span><br><span class="line">            amount0Delta &gt; 0</span><br><span class="line">                ? (tokenIn &lt; tokenOut, uint256(amount0Delta))</span><br><span class="line">                : (tokenOut &lt; tokenIn, uint256(amount1Delta));</span><br><span class="line">        if (isExactInput) &#123;</span><br><span class="line">            pay(tokenIn, data.payer, msg.sender, amountToPay);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // either initiate the next swap or pay</span><br><span class="line">            if (data.path.hasMultiplePools()) &#123;</span><br><span class="line">                data.path = data.path.skipToken();</span><br><span class="line">                exactOutputInternal(amountToPay, msg.sender, 0, data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                amountInCached = amountToPay;</span><br><span class="line">                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed</span><br><span class="line">                pay(tokenIn, data.payer, msg.sender, amountToPay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="exactInputSingle-exactInput"><a href="#exactInputSingle-exactInput" class="headerlink" title="exactInputSingle/exactInput"></a>exactInputSingle/exactInput</h4><p>exactInputSingle/exactInput函数用于计算将一种指定数量的token兑换成另一种token时可以做多获得多少的输出量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc ISwapRouter</span><br><span class="line">    function exactInputSingle(ExactInputSingleParams calldata params)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        override</span><br><span class="line">        checkDeadline(params.deadline)</span><br><span class="line">        returns (uint256 amountOut)</span><br><span class="line">    &#123;</span><br><span class="line">        amountOut = exactInputInternal(</span><br><span class="line">            params.amountIn,</span><br><span class="line">            params.recipient,</span><br><span class="line">            params.sqrtPriceLimitX96,</span><br><span class="line">            SwapCallbackData(&#123;path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender&#125;)</span><br><span class="line">        );</span><br><span class="line">        require(amountOut &gt;= params.amountOutMinimum, &#x27;Too little received&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    /// @inheritdoc ISwapRouter</span><br><span class="line">    function exactInput(ExactInputParams memory params)</span><br><span class="line">        external</span><br><span class="line">        payable</span><br><span class="line">        override</span><br><span class="line">        checkDeadline(params.deadline)</span><br><span class="line">        returns (uint256 amountOut)</span><br><span class="line">    &#123;</span><br><span class="line">        address payer = msg.sender; // 第一个交易对肯定需要用户支付token</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            bool hasMultiplePools = params.path.hasMultiplePools(); //路径中是否包含多个交易对</span><br><span class="line">            // the outputs of prior swaps become the inputs to subsequent ones</span><br><span class="line">            params.amountIn = exactInputInternal(</span><br><span class="line">                params.amountIn,</span><br><span class="line">                hasMultiplePools ? address(this) : params.recipient, // 如果是复杂路径交易,中间token由合约自己先代收</span><br><span class="line">                0,</span><br><span class="line">                SwapCallbackData(&#123;</span><br><span class="line">                    path: params.path.getFirstPool(), // only the first pool in the path is necessary</span><br><span class="line">                    payer: payer</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">            // decide whether to continue or terminate</span><br><span class="line">            if (hasMultiplePools) &#123;</span><br><span class="line">                payer = address(this); // 如果是复杂路径交易,中间token由合约自己先代收,所以也需要合约自己支付到下一个流动池</span><br><span class="line">                params.path = params.path.skipToken();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                amountOut = params.amountIn;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        require(amountOut &gt;= params.amountOutMinimum, &#x27;Too little received&#x27;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用的函数exactInputInternal代码如下，它是exactInputSingle的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/// @dev Performs a single exact input swap</span><br><span class="line">function exactInputInternal(</span><br><span class="line">    uint256 amountIn,</span><br><span class="line">    address recipient,</span><br><span class="line">    uint160 sqrtPriceLimitX96,</span><br><span class="line">    SwapCallbackData memory data</span><br><span class="line">) private returns (uint256 amountOut) &#123;</span><br><span class="line">    // allow swapping to the router address with address 0</span><br><span class="line">    if (recipient == address(0)) recipient = address(this);</span><br><span class="line">    (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool(); //路径解码</span><br><span class="line">    bool zeroForOne = tokenIn &lt; tokenOut; //根据地址大小决定池内是token0-&gt;token1还是token1-&gt;token0</span><br><span class="line">    (int256 amount0, int256 amount1) =</span><br><span class="line">        getPool(tokenIn, tokenOut, fee).swap(</span><br><span class="line">            recipient, //收款地址</span><br><span class="line">            zeroForOne,</span><br><span class="line">            amountIn.toInt256(), //输入token的数量</span><br><span class="line">            sqrtPriceLimitX96 == 0</span><br><span class="line">                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)</span><br><span class="line">                : sqrtPriceLimitX96, //价格限制,卖设置最低价,买设置最高价</span><br><span class="line">            abi.encode(data)</span><br><span class="line">        );</span><br><span class="line">    return uint256(-(zeroForOne ? amount1 : amount0)); //输出token数量用负数表示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exactOutputSingle-exactOutput"><a href="#exactOutputSingle-exactOutput" class="headerlink" title="exactOutputSingle/exactOutput"></a>exactOutputSingle/exactOutput</h4><p>exactOutputSingle/exactOutput用于根据指定的最小输出量来计算需要投入token的量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/// @inheritdoc ISwapRouter</span><br><span class="line">function exactOutputSingle(ExactOutputSingleParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (uint256 amountIn)</span><br><span class="line">&#123;</span><br><span class="line">    // avoid an SLOAD by using the swap return data</span><br><span class="line">    amountIn = exactOutputInternal(</span><br><span class="line">        params.amountOut,</span><br><span class="line">        params.recipient,</span><br><span class="line">        params.sqrtPriceLimitX96,</span><br><span class="line">        SwapCallbackData(&#123;path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender&#125;)</span><br><span class="line">    );</span><br><span class="line">    require(amountIn &lt;= params.amountInMaximum, &#x27;Too much requested&#x27;);</span><br><span class="line">    // has to be reset even though we don&#x27;t use it in the single hop case</span><br><span class="line">    amountInCached = DEFAULT_AMOUNT_IN_CACHED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   function exactOutput(ExactOutputParams calldata params)</span><br><span class="line">    external</span><br><span class="line">    payable</span><br><span class="line">    override</span><br><span class="line">    checkDeadline(params.deadline)</span><br><span class="line">    returns (uint256 amountIn)</span><br><span class="line">&#123;</span><br><span class="line">    // it&#x27;s okay that the payer is fixed to msg.sender here, as they&#x27;re only paying for the &quot;final&quot; exact output</span><br><span class="line">    // swap, which happens first, and subsequent swaps are paid for within nested callback frames</span><br><span class="line">    exactOutputInternal(</span><br><span class="line">        params.amountOut,</span><br><span class="line">        params.recipient,</span><br><span class="line">        0,</span><br><span class="line">        SwapCallbackData(&#123;path: params.path, payer: msg.sender&#125;)</span><br><span class="line">    );</span><br><span class="line">    amountIn = amountInCached;</span><br><span class="line">    require(amountIn &lt;= params.amountInMaximum, &#x27;Too much requested&#x27;);</span><br><span class="line">    amountInCached = DEFAULT_AMOUNT_IN_CACHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exactOutputInternal代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> function exactOutputInternal(</span><br><span class="line">    uint256 amountOut,</span><br><span class="line">    address recipient,</span><br><span class="line">    uint160 sqrtPriceLimitX96,</span><br><span class="line">    SwapCallbackData memory data</span><br><span class="line">) private returns (uint256 amountIn) &#123;</span><br><span class="line">    // allow swapping to the router address with address 0</span><br><span class="line">    if (recipient == address(0)) recipient = address(this);</span><br><span class="line">    (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool(); //路径解码</span><br><span class="line">    bool zeroForOne = tokenIn &lt; tokenOut; //根据地址大小决定池内是token0-&gt;token1还是token1-&gt;token0</span><br><span class="line">    (int256 amount0Delta, int256 amount1Delta) =</span><br><span class="line">        getPool(tokenIn, tokenOut, fee).swap(</span><br><span class="line">            recipient,</span><br><span class="line">            zeroForOne,</span><br><span class="line">            -amountOut.toInt256(), //负数表示的是输出token数量</span><br><span class="line">            sqrtPriceLimitX96 == 0</span><br><span class="line">                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)</span><br><span class="line">                : sqrtPriceLimitX96,</span><br><span class="line">            abi.encode(data)</span><br><span class="line">        );</span><br><span class="line">    uint256 amountOutReceived;</span><br><span class="line">    (amountIn, amountOutReceived) = zeroForOne</span><br><span class="line">        ? (uint256(amount0Delta), uint256(-amount1Delta))</span><br><span class="line">        : (uint256(amount1Delta), uint256(-amount0Delta));</span><br><span class="line">    // it&#x27;s technically possible to not receive the full output amount,</span><br><span class="line">    // so if no price limit has been specified, require this possibility away</span><br><span class="line">    if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他合约"><a href="#其他合约" class="headerlink" title="其他合约"></a>其他合约</h3><p><strong>TickLens.sol</strong>, 此工具合约主要用于查询给定的流动池的所有流动性仓位的流动性大小, 这些信息将用于填充Uniswap链下前端信息网站上展示的流动性深度图</p>
<p><strong>Quoter.sol</strong>, 此工具合约主要用于模拟真实交易, 获取实际交易输入输出的token数量, 用户在真实交易前, 链下前端需要预先计算出用户输入token能够预期兑换的输出token数, 但是这个计算工作只有链上的流动池合约自己能做到, 而且流动池合约中的swap函数都是会更改合约状态的external函数, 需要消耗gas费, 那么就需要把这个操作当作view/pure函数来使用, 本合约为了实现这个目的而存在. 备注: 新版本此合约已经升级成最新的QuoterV2版本, 新版本合约可以查询更多信息, 比如gas评估等</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/VVolfBite/">VVolfBite</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://vvolfbite.github.io/2023/11/25/Uniswap%E5%90%88%E7%BA%A6%E8%A7%A3%E6%9E%90/Uniswap%E5%90%88%E7%BA%A6%E8%A7%A3%E6%9E%90/">http://vvolfbite.github.io/2023/11/25/Uniswap%E5%90%88%E7%BA%A6%E8%A7%A3%E6%9E%90/Uniswap%E5%90%88%E7%BA%A6%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://VVolfBite.github.io" target="_blank">VVolfBite</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Solidity/">Solidity</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E5%90%88%E7%BA%A6/">合约</a></div><div class="post_share"><div class="social-share" data-image="/img/a6.png" data-sites="facebook,twitter,weibo,wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/11/25/%E8%AF%AD%E8%A8%80Solidity/%E8%AF%AD%E8%A8%80Solidity/" title="语言Solidity"><img class="cover" src="/img/a5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">语言Solidity</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Uniswap%E5%90%88%E7%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">Uniswap合约</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%90%88%E7%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">核心合约</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Factory%E5%90%88%E7%BA%A6"><span class="toc-number">1.1.1.</span> <span class="toc-text">Factory合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PoolDeployer%E5%90%88%E7%BA%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">PoolDeployer合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pool%E5%90%88%E7%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">Pool合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Initialize"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Initialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mint"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">Mint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Burn"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Burn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collect"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">Collect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swap"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">Swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flash"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">Flash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProtocalFee"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">ProtocalFee</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Snapshot"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">Snapshot</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E5%9B%B4%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">外围合约</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NonfungiblePositionManger%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">NonfungiblePositionManger合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mint-1"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Mint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Burn-1"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">Burn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#increaseLiquidity"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">increaseLiquidity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decreaseLiquidity"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">decreaseLiquidity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#collect"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">collect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#muticall"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">muticall</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SWAPROUTER%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">SWAPROUTER合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getpool"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">getpool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SwapCallBack"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">SwapCallBack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exactInputSingle-exactInput"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">exactInputSingle&#x2F;exactInput</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exactOutputSingle-exactOutput"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">exactOutputSingle&#x2F;exactOutput</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">其他合约</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/a6.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By VVolfBite</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8832521054" data-server="netease" data-type="playlist" data-autoplay="false" data-lrcType="0"> </div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="100" alpha="0.7" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="/%5Bobject%20Object%5D"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>